---
title: "Interfaces: Definindo Contratos em TypeScript"
description: "Aprenda a usar Interfaces em TypeScript para criar contratos robustos que garantem a 'forma' de objetos e classes, promovendo um código mais desacoplado e flexível."
---

import { Aside } from '@astrojs/starlight/components';
import { TabItem, Tabs } from '@astrojs/starlight/components';

Além das classes abstratas, o TypeScript nos oferece outra ferramenta poderosa para definir "contratos": as **Interfaces**.

Uma interface é uma estrutura que define a sintaxe que uma entidade (como uma classe, um objeto ou até uma função) deve seguir. Ela descreve a "forma" que essa entidade deve ter, mas **sem fornecer nenhuma implementação**.

<Aside type="tip" title="Analogia: O Manual de Instruções">
Pense em uma interface como o manual de instruções para construir um aparelho eletrônico. O manual diz: "Este aparelho deve ter um botão de ligar, um botão de volume e uma tela". Ele não diz *como* esses componentes devem ser fabricados internamente, apenas que eles **devem existir**. Qualquer fabricante que seguir o manual estará criando um aparelho "compatível".
</Aside>

## Usando Interfaces com Classes e Objetos

O uso mais comum de interfaces é para garantir que uma classe tenha um conjunto específico de métodos e propriedades. Usamos a palavra-chave `implements` para isso.

```typescript
// Definindo o contrato
interface Imprimivel {
  // A interface diz que qualquer objeto Imprimivel DEVE ter um método chamado `imprimir`.
  // Este método não recebe parâmetros e não retorna nada (void).
  imprimir(): void;
}

// A classe Fatura é OBRIGADA a fornecer uma implementação para o método `imprimir`.
class Fatura implements Imprimivel {
  constructor(public numero: number, public valor: number) {}

  imprimir(): void {
    console.log(`Fatura #${this.numero} - Valor: R$${this.valor}`);
  }
}

// A classe Relatorio também implementa o contrato, mas de uma forma diferente.
class Relatorio implements Imprimivel {
  constructor(public titulo: string) {}

  // A classe Relatorio também implementa o contrato, mas de uma forma diferente.
  imprimir(): void {
    console.log(`Imprimindo relatório: ${this.titulo}`);
  }
}
```
Se uma classe usa `implements Imprimivel` mas não fornece um método `imprimir()` com a assinatura correta, o TypeScript acusará um erro de compilação.

## Usando Interfaces com Funções

Uma capacidade menos conhecida, mas muito poderosa, das interfaces é a de descrever a **"forma" de uma função**. Isso é útil quando você quer garantir que uma variável ou parâmetro seja uma função que aceite certos argumentos e retorne um certo tipo de valor.

A sintaxe é um pouco diferente: a interface não tem um nome para a função, ela *é* a própria assinatura da função.

```typescript
// Esta interface descreve uma função que:
// - Recebe um parâmetro 'nome' do tipo string.
// - Retorna um valor do tipo string.
interface FuncaoDeSaudacao {
  (nome: string): string;
}

// Agora podemos usar essa interface para tipar uma variável.
// O TypeScript irá garantir que 'cumprimentar' corresponda ao contrato.
const cumprimentar: FuncaoDeSaudacao = (nome) => {
  return `Olá, ${nome}!`;
};

const despedir: FuncaoDeSaudacao = (pessoa) => {
  return `Até mais, ${pessoa}!`;
};

console.log(cumprimentar('Mundo')); // Saída: Olá, Mundo!
console.log(despedir('Ana'));     // Saída: Até mais, Ana!

// O código abaixo daria um erro, pois não segue o contrato:
// const invalido: FuncaoDeSaudacao = (numero: number) => { return numero; };
```
Isso é útil para criar APIs flexíveis, como em funções que recebem outras funções (callbacks) como argumento.

## Comparação: `interface` vs. `abstract class` vs. `type`

Interfaces, classes abstratas e tipos (`type alias`) podem, à primeira vista, parecer ter propósitos sobrepostos, mas é importante entender quais são suas diferenças para escrever um código TypeScript limpo e idiomático.

<Tabs>
<TabItem label="Interface">
**Foco:** Descrever a **forma** de uma entidade (objeto, classe ou função).

-   **O que é:** Um contrato puramente estrutural. Não gera código JavaScript.
-   **Herança:** Pode `extends` outra(s) interface(s).
-   **Implementação:** Uma classe pode `implements` múltiplas interfaces.
-   **Declaration Merging:** Se você declarar a mesma interface duas vezes, suas propriedades são unidas. Isso é útil para estender interfaces de bibliotecas de terceiros.

```typescript
interface Ponto { x: number; }
interface Ponto { y: number; }
const p: Ponto = { x: 10, y: 20 }; // Válido!
```

**Quando usar:** A escolha padrão para definir a forma de objetos e para criar contratos para classes e funções.
</TabItem>

<TabItem label="Type Alias">
**Foco:** Dar um **apelido** a qualquer tipo, incluindo tipos primitivos, uniões, tuplas, etc.

-   **O que é:** Um apelido. Não é um novo tipo, apenas um nome diferente para um tipo existente.
-   **Flexibilidade:** Pode representar tipos mais complexos que interfaces não conseguem, como tipos de união (`string | number`) ou tipos mapeados.
-   **Declaration Merging:** Não suporta. Você não pode declarar o mesmo `type` duas vezes.

```typescript
type ID = string | number;
type Ponto = { x: number; y: number; };
type Status = 'ativo' | 'inativo';
```

**Quando usar:** Para tipos de união, tuplas, ou quando você quer apenas um apelido simples para um tipo primitivo ou um objeto sem a intenção de que ele seja implementado por uma classe.
</TabItem>

<TabItem label="Abstract Class">
**Foco:** Criar uma **classe base** que compartilha código e define um contrato.

-   **O que é:** Uma classe "real" que é transpilada para JavaScript, mas que não pode ser instanciada diretamente.
-   **Herança:** Uma classe só pode `extends` uma única classe (abstrata ou não).
-   **Implementação:** Pode conter tanto métodos abstratos (sem implementação) quanto métodos concretos (com implementação), que são herdados pelas classes filhas.

```typescript
abstract class Animal {
  // Método concreto (compartilhado)
  mover() { console.log('Movendo...'); }
  // Método abstrato (contrato)
  abstract fazerBarulho(): void;
}
```

**Quando usar:** Quando você tem um grupo de classes relacionadas (relação "é um tipo de") e quer **compartilhar código implementado** entre elas, além de forçar um contrato.
</TabItem>
</Tabs>

<Aside type="tip">
**Regra geral:** Prefira usar **interfaces** para definir contratos. Use **classes abstratas** apenas quando precisar compartilhar lógica implementada entre classes que possuem uma clara relação de herança "é um tipo de".
</Aside>

No Nest.js, você encontrará todos eles:
-   **Interfaces** para definir os "contratos" dos componentes (`PipeTransform`, `CanActivate`).
-   **Classes (incluindo abstratas)** como a base da sua aplicação (`Controller`, `Service`).
-   **Types** para definir DTOs simples ou tipos de dados customizados dentro da sua lógica de negócio.