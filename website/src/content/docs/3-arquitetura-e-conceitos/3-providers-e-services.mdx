---
title: "Providers e Inje√ß√£o de Depend√™ncia: A L√≥gica de Neg√≥cio"
description: "Mergulhe no conceito de Providers e aprenda como o sistema de Inje√ß√£o de Depend√™ncia do Nest.js promove um c√≥digo desacoplado, test√°vel e reutiliz√°vel."
---

import { Aside } from '@astrojs/starlight/components';

Se os Controllers s√£o os "gar√ßons" que recebem os pedidos, os **Providers** s√£o os "chefs" que preparam a comida. Eles s√£o a espinha dorsal da sua aplica√ß√£o, onde a l√≥gica de neg√≥cio, o acesso a dados e outras tarefas complexas residem.

O tipo mais comum de Provider √© o **Service**.

## O que √© um Provider?

No Nest.js, um Provider √© qualquer classe marcada com o decorator `@Injectable()`. Este decorator informa ao Nest que a classe pode ser gerenciada pelo seu **cont√™iner de Invers√£o de Controle (IoC)**.

Isso significa que o Nest se encarrega de criar uma inst√¢ncia (um objeto) dessa classe e "injet√°-la" onde ela for necess√°ria, como em um Controller ou em outro Provider. Esse processo √© chamado de **Inje√ß√£o de Depend√™ncia (DI)**.

```typescript
// src/users/users.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { User } from './entities/user.entity'; // Supondo uma entidade User

@Injectable()
export class UsersService {
  // Em um app real, isso seria uma conex√£o com o banco de dados.
  private readonly users: User[] = [
    { id: 1, name: 'John Doe' },
    { id: 2, name: 'Jane Smith' },
  ];

  findAll(): User[] {
    return this.users;
  }

  findOne(id: number): User {
    const user = this.users.find((user) => user.id === id);
    if (!user) {
      throw new NotFoundException(`User with ID "${id}" not found`);
    }
    return user;
  }
}
```
Este `UsersService` encapsula toda a l√≥gica relacionada aos usu√°rios. Ele n√£o sabe nada sobre requisi√ß√µes HTTP; seu √∫nico trabalho √© gerenciar usu√°rios.

## Inje√ß√£o de Depend√™ncia em A√ß√£o

A verdadeira for√ßa dos Providers √© revelada quando os injetamos em outras classes. Vamos ver como um `UsersController` pode usar o `UsersService`.

1.  **Declarar o Provider no M√≥dulo:** Primeiro, voc√™ precisa registrar o `UsersService` no array `providers` do m√≥dulo correspondente (`UsersModule`). Isso permite que o Nest saiba que ele existe.

    ```typescript
    // src/users/users.module.ts
    import { Module } from '@nestjs/common';
    import { UsersController } from './users.controller';
    import { UsersService } from './users.service';

    @Module({
      controllers: [UsersController],
      providers: [UsersService], // Registrando o service
    })
    export class UsersModule {}
    ```

2.  **Injetar no Constructor:** Agora, voc√™ pode "solicitar" uma inst√¢ncia do `UsersService` no `constructor` do `UsersController`.

    ```typescript
    // src/users/users.controller.ts
    import { Controller, Get, Param, ParseIntPipe } from '@nestjs/common';
    import { UsersService } from './users.service';

    @Controller('users')
    export class UsersController {
      // A m√°gica acontece aqui!
      constructor(private readonly usersService: UsersService) {}

      @Get()
      findAll() {
        return this.usersService.findAll();
      }

      @Get(':id')
      findOne(@Param('id', ParseIntPipe) id: number) {
        return this.usersService.findOne(id);
      }
    }
    ```

Quando o Nest.js cria a inst√¢ncia do `UsersController`, ele v√™ que o construtor precisa de um `UsersService`. Ele ent√£o procura por uma inst√¢ncia de `UsersService` no seu cont√™iner IoC e a "injeta" automaticamente.

<Aside title="üîÅ O que √© Invers√£o de Controle (IoC)?">
Sem IoC, a classe `UsersController` seria respons√°vel por criar sua pr√≥pria inst√¢ncia do `UsersService` (ex: `this.usersService = new UsersService()`). Com IoC, o **controle** sobre a cria√ß√£o de depend√™ncias √© **invertido**: a classe n√£o cria mais suas depend√™ncias, ela as recebe de uma for√ßa externa (o cont√™iner do Nest.js). A Inje√ß√£o de Depend√™ncia √© a forma como essa invers√£o √© implementada.
</Aside>

## Vantagens da Inje√ß√£o de Depend√™ncia

Este padr√£o arquitet√¥nico traz benef√≠cios enormes:

-   **Baixo Acoplamento:** O `UsersController` n√£o precisa saber *como* criar um `UsersService` ou do que ele depende. Ele apenas sabe que existe um "contrato" (uma classe `UsersService`) que pode ser usado. Isso torna as classes mais independentes.

-   **Testabilidade Aprimorada:** Ao escrever testes unit√°rios para o `UsersController`, voc√™ pode facilmente fornecer uma vers√£o "mock" (falsa) do `UsersService`. Isso permite testar o controller de forma isolada, sem precisar de um banco de dados real, por exemplo.

-   **Reutiliza√ß√£o de C√≥digo:** O mesmo `UsersService` pode ser injetado em qualquer outro Provider ou Controller que precise de l√≥gica de usu√°rio, sem duplicar c√≥digo. Por padr√£o, o Nest.js cria uma **√∫nica inst√¢ncia (Singleton)** de cada provider e a compartilha por toda a aplica√ß√£o.

## Escopos de Provider (Avan√ßado)

Embora o padr√£o `Singleton` seja o mais comum, o Nest.js permite controlar o ciclo de vida de um provider com escopos:

-   **`SINGLETON`** (padr√£o): Uma √∫nica inst√¢ncia √© criada e compartilhada por toda a aplica√ß√£o.
-   **`REQUEST`**: Uma nova inst√¢ncia √© criada para cada requisi√ß√£o recebida. √ötil para armazenar dados espec√≠ficos de uma requisi√ß√£o (ex: dados do usu√°rio autenticado).
-   **`TRANSIENT`**: Uma nova inst√¢ncia √© criada toda vez que o provider √© injetado.

Voc√™ pode definir o escopo ao registrar o provider:
```typescript
{
  provide: UsersService,
  useClass: UsersService,
  scope: Scope.REQUEST, // Exemplo de escopo de requisi√ß√£o
}
```

Dominar Providers e a Inje√ß√£o de Depend√™ncia √© fundamental para escrever aplica√ß√µes Nest.js limpas, escal√°veis e f√°ceis de manter.
